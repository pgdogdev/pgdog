//! Communication to/from connected clients.

use std::net::SocketAddr;
use std::ops::Deref;
use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

use fnv::FnvHashMap as HashMap;
use once_cell::sync::Lazy;
use parking_lot::Mutex;
use tokio::sync::Notify;
use tokio_util::task::TaskTracker;

use crate::net::messages::BackendKeyData;
use crate::net::Parameters;

use super::{ConnectedClient, Stats};

static COMMS: Lazy<Comms> = Lazy::new(Comms::new);

/// Get global communication channel.
pub fn comms() -> Comms {
    COMMS.clone()
}

/// Sync primitives shared between all clients.
#[derive(Debug)]
struct Global {
    shutdown: Arc<Notify>,
    offline: AtomicBool,
    // This uses the FNV hasher, which is safe,
    // because BackendKeyData is randomly generated by us,
    // not by the client.
    clients: Mutex<HashMap<BackendKeyData, ConnectedClient>>,
    tracker: TaskTracker,
}

/// Bi-directional communications between client and internals.
#[derive(Clone, Debug)]
pub struct Comms {
    global: Arc<Global>,
}

impl Default for Comms {
    fn default() -> Self {
        Self::new()
    }
}

impl Comms {
    /// Create new communications channel between a client and pgDog.
    fn new() -> Self {
        Self {
            global: Arc::new(Global {
                shutdown: Arc::new(Notify::new()),
                offline: AtomicBool::new(false),
                clients: Mutex::new(HashMap::default()),
                tracker: TaskTracker::new(),
            }),
        }
    }

    /// Get all connected clients.
    pub fn clients(&self) -> HashMap<BackendKeyData, ConnectedClient> {
        self.global.clients.lock().clone()
    }

    /// Number of connected clients.
    pub fn clients_len(&self) -> usize {
        self.global.clients.lock().len()
    }

    pub fn tracker(&self) -> &TaskTracker {
        &self.global.tracker
    }

    /// Get number of connected clients.
    pub fn len(&self) -> usize {
        self.global.clients.lock().len()
    }

    /// There are no connected clients.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// New client connected.
    pub fn connect(&self, id: &BackendKeyData, addr: SocketAddr, params: &Parameters) {
        self.global
            .clients
            .lock()
            .insert(*id, ConnectedClient::new(id, addr, params));
    }

    /// Update client parameters.
    pub fn update_params(&self, id: &BackendKeyData, params: Parameters) {
        let mut guard = self.global.clients.lock();
        if let Some(entry) = guard.get_mut(&id) {
            entry.paramters = params;
        }
    }

    /// Client disconnected.
    pub fn disconnect(&self, id: &BackendKeyData) {
        self.global.clients.lock().remove(id);
    }

    /// Update stats.
    pub fn update_stats(&self, id: &BackendKeyData, stats: Stats) {
        let mut guard = self.global.clients.lock();
        if let Some(entry) = guard.get_mut(id) {
            entry.stats = stats;
        }
    }

    /// Notify clients pgDog is shutting down.
    pub fn shutdown(&self) {
        self.global.offline.store(true, Ordering::Relaxed);
        self.global.shutdown.notify_waiters();
        self.global.tracker.close();
    }

    /// Wait for shutdown signal.
    pub fn shutting_down(&self) -> Arc<Notify> {
        self.global.shutdown.clone()
    }

    /// pgDog is shutting down now.
    pub fn offline(&self) -> bool {
        self.global.offline.load(Ordering::Relaxed)
    }
}

#[derive(Debug, Clone)]
pub struct ClientComms {
    comms: Comms,
    id: BackendKeyData,
}

impl Deref for ClientComms {
    type Target = Comms;

    fn deref(&self) -> &Self::Target {
        &self.comms
    }
}

impl ClientComms {
    pub fn disconnect(&self) {
        self.comms.disconnect(&self.id);
    }

    pub fn update_stats(&self, stats: Stats) {
        self.comms.update_stats(&self.id, stats);
    }

    pub fn new(id: &BackendKeyData) -> Self {
        Self {
            id: id.clone(),
            comms: comms(),
        }
    }

    pub fn connect(&self, addr: SocketAddr, params: &Parameters) {
        self.comms.connect(&self.id, addr, params)
    }

    pub fn update_params(&self, params: &Parameters) {
        self.comms.update_params(&self.id, params.clone());
    }
}
