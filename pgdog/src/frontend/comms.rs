//! Communication to/from connected clients.

use std::net::SocketAddr;
use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc,
};

use fnv::FnvHashMap as HashMap;
use once_cell::sync::Lazy;
use parking_lot::Mutex;
use tokio::sync::Notify;
use tokio_util::task::TaskTracker;

use crate::net::messages::BackendKeyData;
use crate::net::Parameters;

use super::{ConnectedClient, Stats};

static COMMS: Lazy<Comms> = Lazy::new(Comms::new);

/// Get global communication channel.
pub(crate) fn comms() -> Comms {
    COMMS.clone()
}

/// Sync primitives shared between all clients.
#[derive(Debug)]
struct Global {
    shutdown: Arc<Notify>,
    offline: AtomicBool,
    // This uses the FNV hasher, which is safe,
    // because BackendKeyData is randomly generated by us,
    // not by the client.
    clients: Mutex<HashMap<BackendKeyData, ConnectedClient>>,
    tracker: TaskTracker,
}

/// Bi-directional communications between client and internals.
#[derive(Clone, Debug)]
pub(crate) struct Comms {
    global: Arc<Global>,
    id: Option<BackendKeyData>,
}

impl Default for Comms {
    fn default() -> Self {
        Self::new()
    }
}

impl Comms {
    /// Create new communications channel between a client and pgDog.
    fn new() -> Self {
        Self {
            global: Arc::new(Global {
                shutdown: Arc::new(Notify::new()),
                offline: AtomicBool::new(false),
                clients: Mutex::new(HashMap::default()),
                tracker: TaskTracker::new(),
            }),
            id: None,
        }
    }

    /// Get all connected clients.
    pub(crate) fn clients(&self) -> HashMap<BackendKeyData, ConnectedClient> {
        self.global.clients.lock().clone()
    }

    /// Number of connected clients.
    pub(crate) fn clients_len(&self) -> usize {
        self.global.clients.lock().len()
    }

    pub(crate) fn clients_memory(&self) -> usize {
        self.global
            .clients
            .lock()
            .values()
            .map(|v| v.stats.memory_used)
            .sum::<usize>()
    }

    pub(crate) fn tracker(&self) -> &TaskTracker {
        &self.global.tracker
    }

    /// Get number of connected clients.
    pub(crate) fn len(&self) -> usize {
        self.global.clients.lock().len()
    }

    /// There are no connected clients.
    pub(crate) fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// New client connected.
    pub(crate) fn connect(
        &mut self,
        id: &BackendKeyData,
        addr: SocketAddr,
        params: &Parameters,
    ) -> Self {
        self.global
            .clients
            .lock()
            .insert(*id, ConnectedClient::new(addr, params));
        self.id = Some(*id);
        self.clone()
    }

    /// Update client parameters.
    pub(crate) fn update_params(&self, params: &Parameters) {
        if let Some(id) = self.id {
            let mut guard = self.global.clients.lock();
            if let Some(entry) = guard.get_mut(&id) {
                entry.paramters = params.clone();
            }
        }
    }

    /// Client disconnected.
    pub(crate) fn disconnect(&mut self) {
        if let Some(id) = self.id.take() {
            self.global.clients.lock().remove(&id);
        }
    }

    /// Update stats.
    pub(crate) fn stats(&self, stats: Stats) {
        if let Some(ref id) = self.id {
            let mut guard = self.global.clients.lock();
            if let Some(entry) = guard.get_mut(id) {
                entry.stats = stats;
            }
        }
    }

    /// Notify clients pgDog is shutting down.
    pub(crate) fn shutdown(&self) {
        self.global.offline.store(true, Ordering::Relaxed);
        self.global.shutdown.notify_waiters();
        self.global.tracker.close();
    }

    /// Wait for shutdown signal.
    pub(crate) fn shutting_down(&self) -> Arc<Notify> {
        self.global.shutdown.clone()
    }

    /// pgDog is shutting down now.
    pub(crate) fn offline(&self) -> bool {
        self.global.offline.load(Ordering::Relaxed)
    }

    pub(crate) fn client_id(&self) -> BackendKeyData {
        self.id.unwrap_or_default()
    }
}
